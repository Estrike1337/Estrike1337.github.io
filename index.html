<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-《Effective C++》读书笔记 2.构造_析构_赋值运算" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/03/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%202.%E6%9E%84%E9%80%A0_%E6%9E%90%E6%9E%84_%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/" class="article-date">
  <time datetime="2021-02-03T13:44:57.116Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/03/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%202.%E6%9E%84%E9%80%A0_%E6%9E%90%E6%9E%84_%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/">《Effective C++》读书笔记 2.构造_析构_赋值运算</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>编译器自动生成copy构造函数、copy assignment操作符、default构造函数（没有声明任何构造函数的时候） <strong>这些函数都是public且inline的</strong></p>
<p><strong>注意，只有在这些函数被需要（被调用）的时候它们才会被编译器创造出来</strong></p>
<p>关于copy构造函数和copy assignment操作符=，只有当生出的代码合法且有适当机会证明它有意义，编译器才会自动生出。<strong>比如成员变量里面有引用或者const，无法赋值，编译器没法解决，就不生成</strong></p>
<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>编译器自动生成的函数是public的，所以不安全<br>解决方法：<br>一、将成员函数声明为private而且故意不实现它们<br>如果实现了，会存在被友元或成员函数调用的风险</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">private</span>;</span><br><span class="line">...</span><br><span class="line">HomeForSale(<span class="keyword">const</span> HomeForSale&amp;);		<span class="comment">//只有声明</span></span><br><span class="line">HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp;);</span><br></pre></td></tr></table></figure>
<p>二、专门设计一个阻止copying动作的base class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Uncopyable()&#123;&#125;		<span class="comment">//允许derived对象构造和析构</span></span><br><span class="line">	~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Uncopyable(<span class="keyword">const</span> Uncopyable&amp;); <span class="comment">//阻止copying</span></span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span><span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><p><strong>带有virtual函数的class都几乎确定应该也有一个virtual析构函数</strong>以防内存泄漏</p>
<p><strong>virtual函数导致class生成虚函数表，会增大存储空间</strong></p>
<p>对于析构函数不是virtual的class，不适合作为base class，典型代表是string类以及STL里面的类</p>
<p>又由于所有对象析构时，最后都会调用其基类的析构函数，所以基类的析构函数必须有定义。纯虚析构函数也不例外。<br>所以，<strong>必须为基类的纯虚析构函数提供一个定义</strong>，否则，链接器会发出抱怨的。</p>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序</p>
<p>析构期间出现错误，强迫结束的意义在于阻止异常传播</p>
<p>如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</p>
<p>可以为行为上可能存在异常的类别设置对应的操作类，进一步封装潜在的错误操作，并将相关的处理移至其他地方</p>
<h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>在derived class对象的base class构造期间，对象类型是base class而不是derived class，virtual函数会被编译器解析至base class</p>
<p>这里的意思是，在构造和析构函数里调用虚函数，效果等效于非虚函数，没有意义</p>
<p><strong>解决方法</strong>：将base class中的virtual关键字去掉，在derived构造函数传递必要信息（参数）给原函数</p>
<h2 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令operator=返回一个reference to *this</h2><p>为实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。</p>
<h2 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在operator=中处理“自我赋值”</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)<span class="comment">//一份不安全的operator=实现版本</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb=<span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果=操作符左右是同一个对象，则delete会同时销毁当前对象和rhs的bitmap，导致后续出错</p>
<p><strong>解决方法：</strong><br>copy and swap技术：对右值做复制，将临时值与对象swap</p>
<p><strong>总结：</strong></p>
<p>确保当对象自我赋值时，operator=有良好的行为。其中技术包括比较“来源对象”和“目标对象”的地址（证同测试）、精心的语句顺序、copy-and-swap技术</p>
<p><strong>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</strong></p>
<h1 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h1><p>如果你为class添加一个成员变量，记得同时修改copying函数</p>
<p><strong>一旦存在继承，在copying函数中不要忘记对base class中的成员变量操作</strong>。如果那些成员是private，则应调用base class中的copying 函数</p>
<p>不要尝试以某个copying函数实现另一个copying函数，应该将共同机能放进第三个函数，并由两个copying函数共同调用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/02/03/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%202.%E6%9E%84%E9%80%A0_%E6%9E%90%E6%9E%84_%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/" data-id="ckkphgwao00003cwp5z006ec1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Effective C++》读书笔记 1.让自己习惯C++" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/01/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%201.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/" class="article-date">
  <time datetime="2021-02-01T08:40:45.752Z" itemprop="datePublished">2021-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/01/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%201.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/">《Effective C++》读书笔记 1.让自己习惯C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>将C++视为四个主要次语言的联邦</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<p>不同次语言的高效编程守则要求可能不同</p>
<hr>
<h2 id="条款02：尽量以const，enum，inline替代-define"><a href="#条款02：尽量以const，enum，inline替代-define" class="headerlink" title="条款02：尽量以const，enum，inline替代#define"></a>条款02：尽量以const，enum，inline替代#define</h2><p><strong>define的坏处</strong><br>不利于维护，安全性弱<br><strong>1.用const取代</strong></p>
<p>定义常量指针：注意const的放置</p>
<p>class专属常量：为确保常量至多只有一份实体，必须让它成为static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns=<span class="number">5</span>;<span class="comment">//常量声明式</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以上存在于头文件中</span></span><br><span class="line"><span class="comment">//以下存在于实现文件中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//NumTurns的定义；</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns;<span class="comment">//常量声明式</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以上存在于头文件中</span></span><br><span class="line"><span class="comment">//以下存在于实现文件中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns=<span class="number">5</span>;<span class="comment">//NumTurns的定义；</span></span><br></pre></td></tr></table></figure>
<p>若它是个class专属常量又是static且为整数类型（integral type，例如int，char，bool），则在其不被后续操作取地址的情况下可以无须提供定义式</p>
<p><strong>2.用enum取代</strong><br>在class编译期间需要一个class常量值，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; NumTurns=<span class="number">5</span>&#125;;			<span class="comment">//“the enum hack”</span></span><br><span class="line">	<span class="keyword">int</span> scores[NumTurns];		<span class="comment">//使用该常量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以上存在于头文件中</span></span><br><span class="line"><span class="comment">//以下存在于实现文件中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//NumTurns的定义；</span></span><br></pre></td></tr></table></figure>
<p>理论基础:<strong>一个属于枚举类型（enumerated type）的数值可权充int</strong><br><strong>与define相似的地方</strong><br>无法取对应的地址（#define也得到，功能相似）<br>不想别人获得pointer或reference指向该资源</p>
<p><strong>3.用inline取代</strong></p>
<p>某些时候，宏定义的函数会导向奇怪的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以a和b的较大值调用函数f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">0</span>;</span><br><span class="line">CALL_WiTH_MAX(++a,b);	<span class="comment">//a被累加二次</span></span><br><span class="line">CALL_WITH_MAX(++a,b+<span class="number">10</span>);<span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>
<p>可以用template inline的函数取代；因为inline的函数也相当于内部直接插入一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>对于单纯常量，最好以const对象或enums替换#defines</p>
<p>对于形如函数的宏，最好改用inline函数替换</p>
<hr>
<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p>1.<strong>const修饰指针时:</strong><br> const出现在星号左边，表示被指物是常量；在右边表示指针自身是常量<br><strong>const修饰迭代器时:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator iter<span class="comment">//类似T* const</span></span><br><span class="line">const_iterator cIter<span class="comment">//类似 const T*</span></span><br></pre></td></tr></table></figure>
<p>2.<strong>将const实施于成员函数的好处</strong><br>1.使class接口容易被理解，得知哪些函数可以修改对象内容，哪些不行。<br>2.pass by reference-to-const方式传递对象需要有const成员函数可用来处理得到（并经修饰而成）的const对象。<br><strong>两个成员函数如果只是常量性不同，可以被重载</strong></p>
<p>3.<strong>bitwise constness（编译器就是这种）和logical constness</strong></p>
<p>bitwise constness是成员函数只有在不更改对象的任何成员变量时就认为是符合const，这个定义存在一定不足，因为即使编译器查不出更改也可能存在更改,比如改变指针所指</p>
<p>logical constness是一个const成员可以修改它所处对象内的某些bits，但只有在客户端侦测不出的情况下才可以</p>
<p><strong>通过mutable关键字，可以释放掉non-static成员变量的bitwise constness约束，从而在const函数内也可以修改所在对象的mutable成员变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;<span class="comment">//会被更改，即使在const成员函数内</span></span><br></pre></td></tr></table></figure>
<p>4.在const和non-const成员函数中避免重复</p>
<p>实现常量性转除。消除const的性质，具体的做法是在non-const的函数里调用对应的const函数，并实现强制转换（const_cast可以强制消除const属性，static_cast可以实现强制转换）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> text[position];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">		<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结<br>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p>
<p>当const和non-const成员函数存在等价实现，用non-const函数调用const版本可以避免代码重复    </p>
<hr>
<h2 id="条款04：确定对象被使用前已被初始化"><a href="#条款04：确定对象被使用前已被初始化" class="headerlink" title="条款04：确定对象被使用前已被初始化"></a>条款04：确定对象被使用前已被初始化</h2><p><strong>对于无任何成员的内置类型，需要手工初始化</strong></p>
<p>构造函数最好使用初始化列表，而不要在构造函数内赋值操作。初值列列出的成语变量，其排列次序应该和它们在class中的声明次序相同</p>
<p>要区分赋值和初始化，对于class的对象，在构造函数内赋值实际上是先调用了它们的默认构造函数，然后做赋值操作，比较低效</p>
<p>成员的初始化列表本质是调用复制构造函数，效率较高</p>
<p><strong>规则：</strong> 总是在初值列中列出所有成员变量，以免还需记住那些成员变量无需初值</p>
<p>为了免除“跨编译单元之初始化次序”的问题（就是定义文件之间的初始化没有先后顺序），应该以local static对象替换non-local static对象</p>
<p>non-local static：函数外的static对象就是non-local static变量</p>
<p>问题：C++对于不同编译单元内的non-local static对象的初始化次序没有明确定义</p>
<p>解决：用singleton的思想。将每个non-local static变量搬到专属函数内，这些函数返回一个reference指向它所含的对象，然后用户调用这些函数，不直接调用对象。这时，non-local static变成了local static</p>
<p>这种reference-returning函数的形式：定义并初始化一个local static， 然后返回它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"><span class="comment">//替换如下</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> FileSystem fs;</span><br><span class="line">	<span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结:</strong></p>
<p>无任何成员的内置类型，需要手工初始化</p>
<p>构造函数最好使用初始化列表，且列出的成员变量次序应该和它们在class中的声明次序相同</p>
<p>为免除“跨编译单元之初始化次序”问题，请以local static 对象替换 non-local static对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/02/01/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%201.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/" data-id="ckkmbpu0p00002kwp5y58bsat" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020的个人回顾与总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/03/2020%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-01-03T11:02:54.485Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/03/2020%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/">2020的个人回顾与总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2020的个人回顾与总结"><a href="#2020的个人回顾与总结" class="headerlink" title="2020的个人回顾与总结"></a>2020的个人回顾与总结</h1><p>白驹过隙，转眼间来到了2021年，自己也在四个月前到了二十岁，青春的句号也画上了一半。</p>
<p>从小对信息比较敏感，我习惯于把信息记在脑海中而不是留下文字。在以前我囿于井底认为记笔记之类的习惯是能力不足的一种表现。把用在这上面的时间拿去多加强几遍记忆才是更好的选择。到了去年我恍然大悟，<strong>总结和笔记的意义不在于完成后的反复查阅，而是在过程中你必须有详实缜密的思考才能组织好语言</strong>，类似于费曼学习法。这就能倒逼自己找到知识和思维上的漏洞和缺陷。</p>
<p>我最终意识到了思考与信息可视化的重要性和我过于放纵知行不一的严重性。重要的事情被提醒三遍后我才会着手去做。希望现在还不晚，最近两年我高强度在网上找寻相关信息并与身边的一些人交流了想法。对未来的可能略知一二，有了个大致的轮廓。之后结合自身情况简要说明未来规划。</p>
<p>我总能在一系列拖延与犹豫中选择性遗忘曾经的那些自我承诺，最终倒在了自身的惰性下。2020年，我抱着大一不玩，以后何时玩的心态放纵自己在大一打了1000+h的游戏。今年年中制定的七个学习目标只粗糙的完成了三个。降低了自身期望，同时完全厌倦了为了未来而不得不去做某些事的说辞，所以安于现状，没有去做更好的改变。细想如今打电子游戏加起来的时间大概一万小时有余，其能带给我的快乐早已大不如前。比起之前的因热爱而沉迷，现在的我打游戏更像是为了逃避，逃避选择，逃避压力，我害怕失败和后悔所以选择了逃避。</p>
<p>在高中，我所做的不过是好好学习，既没有参加竞赛或者有所成就的天分和心气，又没有决心把勤学苦练做到极致，虽然快乐而轻松，但细想之下,我一直只是在小心翼翼的保护自己，无论是在和何种环境，我都是让自己保持在一个中上的位置，强自尊但又缺乏自信导致我不想在基本评价体系里掉下去被人看不起，又因为害怕失败和沉没成本以及成功后可能带来新的平台中新的高压环境，不敢冲击更高的位置。我始终处于最平庸的舒适区内。</p>
<p>到了大学，枷锁似乎褪去，但我真的迎接到了自由吗？是的，我可以大声地宣告，我不在乎所谓的 GPA，所谓的奖学金，但面对日常琐屑的课堂与作业，我能每一次都做到淡然吗？事实上，<strong>许多矛盾渐渐地为我所遇：用功学习与追求 GPA 是一回事吗？心态淡然与无所追逐是一回事吗？诸如此等，或许我可以轻易地在口头上做出选择，但真正的抉择只在亲身面对时浮现。</strong></p>
<p>我可以什么都不做选择，所谓顺其自然。这样的生活，挺轻松。该上课了，我去了又回；布置作业了，我写完再上交……日子可以一天天这么过下去， 大部分人就是这样做的。一直坚持下去的最后也能有一个不错的收获，一如按时耕作的农人。但这样的收获是我想要的吗，是最适合我的吗？</p>
<p>其实我心里早已明白，我不想要这样的生活，从我平时玩的电子游戏中也能看出，我所爱的是那种来之不易的胜利的,我不屑于展示那些其他人也能轻易达到的成就。但与之矛盾的就是我大部分时候都不会为了达到这些而去付出所有心血，正如之前所言我害怕失败和后悔所以选择了逃避。</p>
<p><strong>出国留学，国内升学，抑或是早日进入职场</strong>。这几条路上，都有前人留下的无数足迹与丰碑，但也无可避免地悬着前人用泪水濯洗的种种失败警示牌。我曾尝试从中选出最优解，然而反复的纠结过后，我所意识到的，是这种比较的注定无结果：每当我觉得某个选择优于其他选择时，总会有某些信息刷新我的认知，让我匆忙撤回自己的决定。一如盲人同时摸象与鲸鱼，用片面的认知去比较复杂的事物，注定失败。</p>
<p>周身四望，多数人并不似我一样在大二就对自己的出路“杞人忧天”，我既羡慕其埋头学习的安然与开怀游乐的自在，又常常感到自我怀疑与无所交流。不过，所幸在相当长一段时间的迷惘之后，时至今日。我渐渐想明白，<strong>与其在分岔路口拼命思索而陷入难以决断的痛苦，陷入到拖延症的无限准备和无穷纠结中，看起来思考了很多，实际上和没有思考过的人依然在同一个起跑线上。不如先找一条路淡然前行。也许我现在纠结的事情，就和小学时纠结以后是上清华还是上北大一样可笑。在大类问题上纠结半天，还会在下一个子类问题上继续纠结。</strong></p>
<p>留给我的时间已经不多了，我已经用了足够的时间获取和筛选信息让我的决策质量更高。目前我已经找到了能适应大部分情况的对于自己而言的最优解，接下来要做的就是付诸行动。战术上和战略上的勤奋都是缺一不可。嫌麻烦不能再成为我知应为之而不为的借口，不给自己后悔的余地。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/03/2020%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/" data-id="ckjh11je500001kwp102o6e94" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-markdown编辑器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/03/markdown%E7%BC%96%E8%BE%91%E5%99%A8/" class="article-date">
  <time datetime="2021-01-03T06:27:29.935Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/03/markdown%E7%BC%96%E8%BE%91%E5%99%A8/">markdown编辑器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><h1 id="欢迎使用Markdown"><a href="#欢迎使用Markdown" class="headerlink" title="欢迎使用Markdown"></a>欢迎使用Markdown</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>
<h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>
<ol>
<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>
<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>
<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>
<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>
<li>增加了支持<strong>甘特图的mermaid语法<a href="[mermaid语法说明](https://mermaidjs.github.io/)">^1</a></strong> 功能；</li>
<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>
<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>
<li>增加了 <strong>检查列表</strong> 功能。</li>
</ol>
<h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>
<h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支## 标题持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>
<h1 id="平安经"><a href="#平安经" class="headerlink" title="平安经"></a>平安经</h1><h2 id="平安jn"><a href="#平安jn" class="headerlink" title="平安jn"></a>平安jn</h2><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>以牙还牙，加倍奉还</em><br><strong>我们中国太厉害了</strong><br><strong>加中国的料，好吃</strong></p>
<p>==阿姨洗铁路==</p>
<p><del>我是猪</del></p>
<blockquote>
<p>引用文本</p>
</blockquote>
<p>H<del>2</del>O is是液体。</p>
<p>2^10^ 运算结果是 1024.</p>
<h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">link</a>.<br><a href="https://estrike1337.github.io/" target="_blank" rel="noopener">俺的博客</a> </p>
<p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p>
<p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>
<p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p>
<p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>
<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>
<h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> girlfriend&#123;<span class="number">18</span>岁白丝jk&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul>
<li>项目<ul>
<li>项目<ul>
<li>项目</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>项目1</li>
<li>项目2</li>
<li>项目3</li>
</ol>
<ul>
<li><input disabled="" type="checkbox"> 计划任务</li>
<li><input checked="" disabled="" type="checkbox"> 完成任务</li>
</ul>
<h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>—- | —- |<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p>
<h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p>
<h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|———————–|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code> |– is en-dash, — is em-dash|<br><code>DADA</code></p>
<h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p>
<h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p>
<p>*[HTML]:   超文本标记语言</p>
<h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p>
<p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p>
<p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p>
<blockquote>
<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li>
</ul>
<h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure>

<p>这将产生一个流程图。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li>
</ul>
<h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li>
</ul>
<h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/03/markdown%E7%BC%96%E8%BE%91%E5%99%A8/" data-id="ckjgr6wv6000018wpgwrv8xu8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/hello-world/" class="article-date">
  <time datetime="2020-07-27T07:39:03.008Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/hello-world/" data-id="ckd4a000p0000g8wphfg8byd3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/03/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%202.%E6%9E%84%E9%80%A0_%E6%9E%90%E6%9E%84_%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/">《Effective C++》读书笔记 2.构造_析构_赋值运算</a>
          </li>
        
          <li>
            <a href="/2021/02/01/%E3%80%8AEffective%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%201.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/">《Effective C++》读书笔记 1.让自己习惯C++</a>
          </li>
        
          <li>
            <a href="/2021/01/03/2020%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/">2020的个人回顾与总结</a>
          </li>
        
          <li>
            <a href="/2021/01/03/markdown%E7%BC%96%E8%BE%91%E5%99%A8/">markdown编辑器</a>
          </li>
        
          <li>
            <a href="/2020/07/27/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>